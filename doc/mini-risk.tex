\documentclass[10pt]{article}
\usepackage{listings}
%\usepackage{fontspec}
%\setmainfont{Linux Libertine O}
%\usepackage{amsfonts}
%\usepackage{multirow}
%\usepackage{amsmath, amssymb}
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage[english]{babel}
%\usepackage[margin=0.8in]{geometry}

\title{Foundations of a Risk Management System \\
\large FE5226 Class Project
}
\author{Fabio Cannizzo}
\date{2017-9-1}

\begin{document}
\maketitle

\abstract{
	The source provided contains the skeleton of risk management system. You are supposed to carry out various improvements and extensions as specified below.
}

\section{License}
The license for the source code is in the main durectory. Please read the license file.
\section{Source code organization}
All source code files are in the subdirectory \textit{src}. Source files with names matchine the patterns \textit{Demo*.cpp} or \textit{Test*.cpp} contain the \textit{main} routine for separate programs. Other cpp files are components used by the programs.

The directory also contains a Makefile for gcc compilation. If you use Visual Studio, you need to create a new solution. In the solution add one console project for each cpp file with name Demo*.cpp or Test*.cpp. In each project add also all other cpp files (except the ones with name Demo*.cpp or Test*.cpp).

A number of txt files are given. \textit{portfolio\_0.txt} and \textit{risk\_factors\_0.txt} work with the program in its current state. \textit{portfolio\_$i$.txt} and \textit{risk\_factors\_$i$.txt} work after completion of the first $i$ tasks.

To run the program type from the command line:\\
\textit{DemoRisk portfolio.txt risk\_factors.txt}

To run the program directly from inside Visual Studio, you can specify the working directory where your txt files are located and the command line arguments (\textit{portfolio.txt risk\_factors.txt}) in the \textit{Debugging} section of the project configuration.

\section{What to do}
You have to complete sequentially all tasks mentioned in the section \ref{sec:task}. After completing each task you should test correctness of your work by succesfully running the command \\
\textit{DemoRisk portfolio\_i.txt risk\_factors\_i.txt}\\
and comparing your results with those given in \textit{output\_i.txt}.

After completing all tasks you need to zip and submit all files with extension *.h and *.cpp. Do not submit any other file (e.g. txt files, project files, object files, executable files).

\section{Marking criteria}
\begin{itemize}
\item Correctness: I will run your DemoRisk with my trade portfolio and my market data and I will compare your results with mine.
\item Indentation: I will mark correct use of indentation (configure your editor to convert tab to spaces and to use tab of 4 characters)
\item Style: proper choices of variable names, use of source code comments
\item minimal diff: only modify the lines of code strictly necessary, do not insert unnecessary whitespaces
\end{itemize}

\section{Tasks}
\label{sec:task}

\subsection{Improve the \textit{Date} class}
The most common operations performed with the \textit{Date} class when pricing are comparison (e.g. $<$, ==, $>$) and computation of distance between two dates. The current internal representation of the date class is not optimal for these operations.

Refactor the \textit{Date} class by modifying the current internal representation, which entails of the 4 data members \textit{day}, \textit{month}, \textit{year} and \textit{is\_leap}, to a single data member of type \textit{unsigned} with name \textit{serial}, representing the number of days elapsed since 1-Jan-1900. This allows to speed up the operations mentioned above and reduce memory footprint.

Change the serialization format to be based directly on \textit{serial}, so that no extra work is necessary when saving or loading from a file.

When the \textit{Date} class is constructed from the arguments \textit{day}, \textit{month} and \textit{year}, you need to generate the equivalent serial \textit{number}. When converting to a string in calendar format for display to the screen, you need to convert \textit{serial} on-the-fly into day, month and year.


\subsection{Write a test for the \textit{Date} class}
Complete the program in \textit{TestDate.cpp}, so that it tests the correctness of the \textit{Date} class. It should perform the following tests:
\begin{enumerate}
\item Construction of an invalid date should generate an error: generate intentionally 1000 random invalid dates (e.g. 31-Apr-2010) and verify that the \textit{Date} class constructor throws an error (use \textit{try...catch}).
\item Verify that converting a date in calendar format to serial format and converting back generate the original date. Repeat for all dates in the valid range (1-Jan-1900, 31-Dec-2199).
\item Verify that the serial number generated for 2 contiguous dates are contiguous. For instance 31-Jan-2012 and 1-Feb-2012 are contiguous dates, hence the serial numbers they generate should only differ by 1. Repeat for all pairs of contiguous dates in the valid range (1-Jan-1900, 31-Dec-2199).
\end{enumerate}
At the begin of the test, randomize the random number generator. If the test fails, the program should throw an exception, if it succeeds it should just print the message "SUCCESS".

\subsection{Remove streaming inaccuracy for type \textit{double}}
Currently when a floating point number in double precision saved to a file it is transformed from IEEE-754 format to a decimal representation with a finite number of decimals in scientific notation. The conversion from IEEE-754 to decimal (when saving) and then back to IEEE-754 (when reading) involves rounding and can cause accuracy loss.

Change the streaming representation of a \textit{double} to the hexadecimal image of its binary representation with letters in lowercase.

If $x$ is a variable of type $double$, then \textit{reinterpret\_cast$<$unsigned char*$>$}(\&$x$) returns a pointer of type \textit{unsigned char*} to the individual bytes of $x$. This allows to read (or write) the bytes composing the double one by one. So you can take each byte, convert it to its hexadecimal representation. For example, the double number -0.15625 should be saved to file as the sequence of 16 characters 000000000000c4bf (see \textit{DemoHex.cpp}). When reading, you can take each pair of characters, convert each into a char and write it into the corresponding byte in the memory space allocated to the variable of type double.

You need to modify the implementation of the \textit{operator$<<$} for \textit{double} and implement the overload of the \textit{operator$>>$} (you may draw inspiration from the ones implemented for the \textit{Date} class).

\subsection{Improve the \textit{CurveDiscount} class}
The current \textit{CurveDiscount} curve assumes that the interest rate curve is constant.

Modify it so that it takes a set of rates related to different tenors and modify it so that when querying for a discount factor, the value returned is correctly interpolated.

For example, given the data points {IR.1W.USD, IR.2W.USD, IR.1M.USD, IR.2M.USD, IR.3M.USD, IR.6M.USD, IR.9M.USD, IR.1Y.USD, IR.18M.USD, IR.2Y.USD, ...}, you need to resolve each of them to an actual date with respect to the anchor date, construct a stepwise constant interpolation scheme, modify the function which returns discount factor.

Since you do not know which points are available in advance in the market, if you want all the available points for the currency EUR, you need to modify the market data server to be able to return the array of risk factors with pattern IR.*.EUR. Use the $<$regex$>$ STL library to search for a string pattern and implemented the method \textit{MarketDataServer::matching}, whose header is already defined in \textit{MarketDataServer.h}. Note that "IR.*.EUR" is not the correct regular expression string to be used here, you need to read about regular expressions and figure out what is the most appropriate string to use, i.e. it should match "just" what needed. For instance, "IR.*EUR" would match "IR.1W.EUR", but also "IRwhateverEUR", which is undesirable.

The interpolation scheme requires computation of the local rates. If $r_i$ and $r_{i+1}$ are the absolute rates for tenor $T_i$ and $T_{i+1}$, as returned from the market data server, the local rate sought $r_{i,i+1}$ is such that the following relation holds:
 $$e^{-r_iT_i-r_{i,i+1}(T_{i+1}-T_i)}=e^{-r_{i+1}T_{i+1}}$$
Then the discount factor for any date $t \in [T_i,T_{i+1}]$ is $$e^{-r_i T_i-r_{i,i+1}(t-T_i)}$$

\subsubsection{PV01 with tenors}
\label{sec:pv01}
The \textit{PV01} risk function needs to be modified into 2 different risk functions: \textit{PV01Parallel} that computes risk with respect to parallel shift of the yield curve (all risk factor move simultaneously); and \textit{PV01Bucketed} that computes risk with respect to individual yield curves (the yield curve for each tenor $T_i$ change, with all the rest remaining constant). In both cases use central differences, with the same bump size as currently defined in \textit{Demo.cpp}. The 2 new functions must have the same signature as the existing one. \\

To test, you can use the file of risk factors provided: \textit{risk-factors-tenors.txt}.

\subsection{Add a new market object \textit{CurveFXSpot}}
The new market object should implement the interface \textit{ICurveFXSpot}.

Note that the risk factors contained by the market data server only include spot currencies in the format CCYUSD, i.e. the prices of CCY in USD. The class must support direct, inverse and cross currency pairs (e.g. EURUSD, USDJPY, EURGBP). It is up to you to make the correct queries to the market data server and construct the \textit{CurveFXSpot} appropriately.\\

You need to add an additional members to the \textit{Market} class as appropriate.\\

Modify the \textit{PricerPayment} class to use the new class \textit{CurveFXSpot}.

\subsection{Add a new market object \textit{CurveFXForward}}
The new market object should implement the interface \textit{ICurveFXForward}.\\

The forward price of currency $ccy_1$ expressed in currency $ccy_2$ for delivery at time $T$ can be computed as
$$F_T=S_t \frac{B_{T,1}}{B_{T,2}}$$
where $S_t$ is the spot price of currency $ccy_1$ expressed in currency $ccy_2$, $B_{T,i}$ is the discount factor in currency $ccy_i$ for time $T$.\\

This class should use the \textit{CurveFXSpot} and \textit{CurveDiscount} classes.\\

You need to add an additional members to the \textit{Market} class as appropriate.

\subsection{Add new trade type \textit{TradeFXForward}}
At time $T$ it pays the following amount of $ccy_2$ at time $T_2$
$$
payoff=N[S_{T_1}-K]
$$
where $S_{T_1}$ is the spot price of currency $ccy_1$ expressed in currency $ccy_2$ for observed at the fixing date $T_1$, $K$ is a predefined strike price, $N$ is the notional amount and $T_2$ is the settlement date (it must be $T_1<T_2$).\\

Assign to the trade ID=3 (arbitrarily chosen) and the following serialized representation:\\
ID;CCY1;CCY2;NOTIONAL;STRIKE;FIXINGDATE;SETTLEDATE;

\noindent Example:\\
3;EUR;USD;notional in hex;1.150e0;date in serial;date in serial;\\

The currency pair $ccy_1ccy_2$ can be any direct, inverse or cross pair.\\

You must be able to load the file \textit{portfolio2.txt}, which contains some trades of this type.\\

Implement the corresponding pricer object. The price in $ccy_2$ can be computed as:
$$
price=B_{T_2,2}[F_{T_1}-K]
$$
where $B_{T,2}$ is the discount factor in currency 2 for settlement date $T$ and $F_T$ is the currency forward price for date $T$. Do not forget to convert this price into USD.\\

\subsubsection{Historical fixings}
Note that when the pricing date $T$ is between $T_1$ and $T_2$, you need to know the value of $S_{T_1}$, which is in the past, i.e. you need to know its fixed value. To achieve that, add to \textit{ITrade} a method\\
\textit{vector$<$pair$<$string,Date$>>$ required\_fixings(condt Date$\&$ until)},\\
which returns the fixings needed by the trade to price on pricing date \textit{until}. If a trade has no fixings, this should return an empty vector.
Modify the \textit{IPrice::price} method to take an extra argument of type\\ $const\; map<string,map<Date,double>>\&\; fixings$\\ and use it in pricers to retrieve necessary fixings. In particular: fixings occurring in the past should be obtained from this argument and if not available an exception should be thrown; fixings occurring exactly on the pricing date should be taken from this argument if available, resolved through the Market otherwise; fixings occurring in the future should be resolved through the Market (e.g. forward prices).

\subsection{Add pricer configuration}
Modify the function \textit{ITrade::Pricer} adding an argument \textit{configuration} of type \textit{string}. In a real risk management system the configuration argument could be very complex and allow for instance to select a pricing model (e.g. Black Scholes or Heston) or a numerical framework (e.g. PDE or Monte Carlo). In this project the configuration string is simply the base currency in which all risk is to be computed. At the moment, by default everything is computed in USD. After your changes, \textit{pricer("EUR")} should return a pricer that computes the price in EUR.\\

You need to modify all pricers accordingly.

\subsection{Recover from pricing failures}
The function \textit{IPricer::price} fails and throws an exception when an error occurs. For instance, if the settlement date of a \textit{Payment} is in the past, pricing of the entire portfolio to fails. We would like instead that only problematic trades to fail to price and all remaining trades to price succesfully.

Modify the typedef \textit{portfolio\_values\_t} to \textit{vector$<$pair$<$double,string$>>$}. In the \textit{compute\_prices} function use \textit{try\{\}catch\{\}} to catch exceptions. If there is no error set the double to the price and the string to an empty string. If there is an error set the double to NaN (see header $<$numeric\_limits$>$) and the string to the error message embedded in the exception.

When computing thet total for the book (function \textit{portfolio\_total}), you should return a tuple containing the total for trades which price succesfully and an array of pairs with the index of the trades which price to fail and the associated error message. To identify trades which fail check is the value is a NaN, not if the error message string is empty, as a trade could potentially fail and still have an ampty error message.

\subsection{Add FX Spot Greek function}
\label{sec:fxdelta}
Add another function for Greeks calculation, named \textit{fx\_delta}, which computes the risk of the book with respect to each of the FX spot rate quoted against USD in the market data server. It should use central difference with a relative bump of 0.1%.

Add calculation of FXDelta at thhe end of \textit{RiskDemo.cpp} and display the cumlative book value for each fx spot rate.

\subsection{Customize bumps in Greeks}

Add to the 2 functions for risk computation implemented in section \ref{sec:pv01} and the one implemented in section \ref{sec:fxdelta} adding an optional extra argument with type\\
\textit{struct GreekConfig \{ double bumpsize; \}}\\
to allow the caller to control the bump size. When this optional extra argument is not explicitly passed by the caller, it should take the current hardcoded bump size as default value.


\end{document}

