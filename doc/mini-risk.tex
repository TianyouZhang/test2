\documentclass[10pt]{article}
\usepackage{listings}
%\usepackage{fontspec}
%\setmainfont{Linux Libertine O}
%\usepackage{amsfonts}
%\usepackage{multirow}
%\usepackage{amsmath, amssymb}
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage[english]{babel}
%\usepackage[margin=0.8in]{geometry}

\title{Foundations of a Risk Management System \\
\large FE5226 Class Project
}
\author{Fabio Cannizzo}
\date{2017-9-1}
\begin{document}
\maketitle

\section{Improving the \textit{Date} class}
The most common operations performed with the \textit{Date} class when pricing are comparison (e.g. $<$, ==, $>$) and computation of distance between two dates. The current internal representation of the date class is not optimal for these operations.

Refactor the \textit{Date} class by modifying the current internal representation, which entails of the 4 data members \textit{day}, \textit{month}, \textit{year} and \textit{is\_leap}, to a single data member of type \textit{unsigned} with name \textit{serial}, representing the number of days elapsed since 1-Jan-1900. This allows to speed up the operations mentioned above and reduce memory footprint.

Change the serialization format to be based directly on \textit{serial}, so that no extra work is necessary when saving or loading from a file.

When the \textit{Date} class is constructed from the arguments \textit{day}, \textit{month} and \textit{year}, you need to generate the equivalent serial \textit{number}. When converting to a string in calendar format for display to the screen, you need to convert \textit{serial} on-the-fly into day, month and year.


\section{Write a test for the \textit{Date} class}
Complete the program in \textit{TestDate.cpp}, so that it tests the correctness of the \textit{Date} class. It should perform the following tests:
\begin{enumerate}
\item Construction of an invalid date should generate an error: generate intentionally 1000 random invalid dates (e.g. 31-Apr-2010) and verify that the \textit{Date} class constructor throws an error (use \textit{try...catch}).
\item Verify that converting a date in calendar format to serial format and converting back generate the original date. Repeat for all dates in the valid range (1-Jan-1900, 31-Dec-2199).
\item Verify that the serial number generated for 2 contiguous dates are contiguous. For instance 31-Jan-2012 and 1-Feb-2012 are contiguous dates, hence the serial numbers they generate should only differ by 1. Repeat for all pairs of contiguous dates in the valid range (1-Jan-1900, 31-Dec-2199).
\end{enumerate}
At the begin of the test, randomize the random number generator. If the test fails, the program should throw an exception, if it succeeds it should just print the message "SUCCESS".

\section{Remove streaming inaccuracy for type \textit{double}}
Currently when a floating point number in double precision saved to a file it is transformed from IEEE-754 format to a decimal representation with a finite number of decimals in scientific notation. The conversion from IEEE-754 to decimal (when saving) and then back to IEEE-754 (when reading) involves rounding and can cause accuracy loss.

Change the streaming representation of a \textit{double} to the hexadecimal image of its binary representation with letters in lowercase. For example, the double number -0.15625 should be saved to file as the sequence of 16 characters 000000000000c4bf (see \textit{DemoHex.cpp}).

If $x$ is a variable of type $double$, then \textit{reinterpret\_cast$<$unsigned char*$>$}(\&$x$) returns a pointer of type \textit{unsigned char*} to the individual bytes of $x$. This allows to read (or write) the bytes composing the double one by one. So you can take each byte, convert it to its hexadecimal representation. When reading, you can take each pair of hexadecimal digit, convert them to a char and write it into the double.

You need to modify the implementation of the \textit{operator$<<$} for \textit{double} and implement the overload the \textit{operator$>>$} (you may draw inspiration from the ones implemented for the \textit{Date} class).

\section{Improve the \textit{CurveDiscount} class}
The current \textit{CurveDiscount} curve assumes that the interest rate curve is constant.

Modify it so that it takes a set of rates related to different tenors and modify it so that when querying for a discount factor, the value returned is correctly interpolated.

For example, given the data points {IR.1W.USD, IR.2W.USD, IR.1M.USD, IR.2M.USD, IR.3M.USD, IR.6M.USD, IR.9M.USD, IR.1Y.USD, IR.18M.USD, IR.2Y.USD, ...}, you need to resolve each of them to an actual date with respect to the anchor date, construct a stepwise constant interpolation scheme, modify the function which returns discount factor.

Since you do not know which points are available in advance in the market, if you want all the available points for the currency EUR, you need to modify the market data server to be able to return the array of risk factors with pattern IR.*.EUR. Use the $<$regex$>$ STL library to search for a string pattern and implemented the method \textit{MarketDataServer::matching}, whose header is already defined in \textit{MarketDataServer.h}. Note that "IR.*.EUR" is not the correct regular expression string to be used here, you need to read about regular expressions and figure out what is the most appropriate string to use.

The interpolation scheme requires computation of the local rates. If $r_i$ and $r_{i+1}$ are the absolute rates for tenor $T_i$ and $T_{i+1}$, as returned from the market data server, the local rate sought $r_{i,i+1}$ is such that the following relation holds:
 $$e^{-r_iT_i-r_{i,i+1}(T_{i+1}-T_i)}=e^{-r_{i+1}T_{i+1}}$$
Then the discount factor for any date $t \in [T_i,T_{i+1}]$ is $$e^{-r_i T_i-r_{i,i+1}(t-T_i)}$$

The \textit{PV01} risk scenario needs to be modified into 2 different scenarios: \textit{PV01Parallel} that computes risk with respect to parallel shift of the yield curve (all risk factor move simultaneously); and \textit{PV01Bucketed} that computes risk with respect to individual yield curves (the yield curve for each tenor $T_i$ change, with all the rest remaining constant). In both cases uses central differences, with the same bump size as currently defined in \textit{Demo.cpp}.\\

To test, you can use the file of risk factors provided: \textit{risk-factors-tenors.txt}.

\section{Add a new market object \textit{CurveFXSpot}}
The new market object should implement the interface \textit{ICurveFXSpot}.

Note that the risk factors contained by the market data server only include spot currencies in the format CCYUSD, i.e. the prices of CCY in USD. The class must support direct, inverse and cross currency pairs (e.g. EURUSD, USDJPY, EURGBP). It is up to you to make the correct queries to the market data server and construct the \textit{CurveFXSpot} appropriately.\\

You need to add an additional members to the \textit{Market} class as appropriate.\\

Modify the \textit{PricerPayment} class to use the new class \textit{CurveFXSpot}.

\section{Add a new market object \textit{CurveFXForward}}
The new market object should implement the interface \textit{ICurveFXForward}.\\

The forward price of currency $ccy_1$ expressed in currency $ccy_2$ for delivery at time $T$ can be computed as
$$F_T=S_t \frac{B_{T,1}}{B_{T,2}}$$
where $S_t$ is the spot price of currency $ccy_1$ expressed in currency $ccy_2$, $B_{T,i}$ is the discount factor in currency $ccy_i$ for time $T$.\\

This class should use the \textit{CurveFXSpot} and \textit{CurveDiscount} classes.\\

You need to add an additional members to the \textit{Market} class as appropriate.

\section{Add new trade type \textit{TradeFXForward}}
At time $T$ it pays the following amount of $ccy_2$
$$
payoff=N[S_T-K]
$$
where $S_T$ is the spot price of currency $ccy_1$ expressed in currency $ccy_2$ for observed at time $T$, $K$ is a predefined strike price and $N$ is the notional amount.\\

Assign to the trade ID=3 and the following serialized representation:\\
ID;CCY1;CCY2;NOTIONAL;STRIKE;

\noindent Example:\\
3;EUR;USD;notional in hex;1.150e0;date in serial;\\

The currency pair $ccy_1ccy_2$ can be any direct, inverse or cross pair.\\

You must be able to load the file portfolio2.txt, which contains some trades of this type.\\

Implement the corresponding pricer object. The price in $ccy_2$ can be computed as:
$$
price=B_{T,2}[F_T-K]
$$

Do not forget to convert this into USD.\\

\section{Add Configuration}
Modify the function \textit{ITrade::Pricer} adding an argument \textit{configuration} of type \textit{string}. In a real risk management system the configuration argument could be very complex and allow for instance to select a pricing model (e.g. Black Scholes or Heston) or a numerical framework (e.g. PDE or Monte Carlo). In this project the configuration string is simply the base currency in which all risk is to be computed. At the moment, by default everything is computed in USD. For instance, \textit{pricer("EUR")} should return a pricer that computes the price in EUR.\\

You need to modify the pricers accordingly.

\section{Minimize market objects recalculations}

\section{Implement query which returns risk factor for a trade}

\section{Minimize trade price recomputations}

\end{document}

